# -*- coding: utf-8 -*-
"""IDHFINAL

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nSoNasXMhNLjuZJ3VVrdNSPKYYFvqFoU
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
import warnings
warnings.filterwarnings('ignore')

#Importando arquivo xls do IDH-Fortaleza
from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

#Ler o arquivo importado
df = pd.read_excel('/content/IDH-Fortaleza.xlsx')

df.head()

#checar o tipo das colunas
df.dtypes

colunas_numericas = ['IDH-Educação', 'IDH-Longevidade', 'IDH-Renda', 'IDH']

# Informações dos dados
print("Dimensões do dataset:", df.shape)
print("Tipos de dados:", df.dtypes)

#definir as colunas requeridas para tipo float
for coluna in colunas_numericas:
    df = df.replace('-', np.nan)
    df[coluna] = df[coluna].astype(float)

#excluir espaços que ficaram nulos
df.dropna(axis=0, inplace=True)

# Selecionar as colunas numéricas para calcular a correlação
numerical_cols = ['IDH-Educação', 'IDH-Longevidade', 'IDH-Renda', 'IDH']
df[numerical_cols].corr()


df.describe()

#definir a cor com base a porcentagem do IDH
def color_bar(idh):
    if idh < 0.2:
        return 'red'
    elif 0.2 <= idh < 0.4:
        return 'orange'
    elif 0.4 <= idh < 0.6:
        return '#ffff00'
    elif 0.6 <= idh < 0.8:
        return 'blue'
    else:
        return 'green'

# Mostrar o gráfico de IDH dos bairros

colors = [color_bar(value) for value in df['IDH']]

plt.figure(figsize=(19, 10))

sns.barplot(x=df['Bairros'], y=df['IDH'], palette=colors)

plt.xlabel('Bairros')

plt.ylabel('IDH')

plt.title('Comparação do IDH por Bairro')

plt.xticks(rotation=90)

plt.yticks(rotation=0)

plt.tight_layout()

plt.show()

# Perguntar ao usuário quais bairros deseja mostrar
input_bairros = input("Quais bairros você quer mostrar? (Separe os nomes por vírgulas): ")
bairros_selecionados = [bairro.strip() for bairro in input_bairros.split(',') if bairro.strip() in df['Bairros'].values]

# Selecionar bairros aleatórios se necessário
if len(bairros_selecionados) < 15:
    bairros_aleatorios = df[~df['Bairros'].isin(bairros_selecionados)]['Bairros'].sample(n=15-len(bairros_selecionados), random_state=1).tolist()
    bairros_finais = bairros_selecionados + bairros_aleatorios
else:
    bairros_finais = bairros_selecionados[:15]  # Garantir que só sejam escolhidos 15 bairros

# Filtrar o DataFrame para mostrar apenas os bairros selecionados
df_filtrado = df[df['Bairros'].isin(bairros_finais)]

# Mostrar o gráfico de IDH dos bairros filtrados
def color_bar(idh):
    if idh < 0.2:
        return 'red'
    elif 0.2 <= idh < 0.4:
        return 'orange'
    elif 0.4 <= idh < 0.6:
        return '#ffff00'
    elif 0.6 <= idh < 0.8:
        return 'blue'
    else:
        return 'green'

colors = [color_bar(value) for value in df_filtrado['IDH']]

plt.figure(figsize=(19, 10))
sns.barplot(x=df_filtrado['Bairros'], y=df_filtrado['IDH'], palette=colors)
plt.xlabel('Bairros')
plt.ylabel('IDH')
plt.title('Comparação do IDH por Bairro')
plt.xticks(rotation=90)
plt.yticks(rotation=0)
plt.tight_layout()
plt.show()

# Criação de novo gráfico detalhando a porcentagem de IDH para cada bairro


idh_data = df[['Bairros', 'IDH-Educação', 'IDH-Longevidade', 'IDH-Renda']]
idh_data = idh_data.set_index('Bairros')

# Configurações do gráfico
fig, ax = plt.subplots(figsize=(30, 12))  # Aumentar o tamanho do gráfico para melhor visualização

# Posições para as barras com menos espaço entre os bairros
bar_width = 0.5  # Aumentar a largura das barras
indices = np.linspace(0, len(idh_data)*1.5, len(idh_data))  # Ajustar o espaçamento para preencher melhor

# Plotar cada componente do IDH com as barras mais largas e ajustadas
ax.bar(indices - bar_width, idh_data['IDH-Educação'], width=bar_width, label='IDH-Educação', color='blue')
ax.bar(indices, idh_data['IDH-Longevidade'], width=bar_width, label='IDH-Longevidade', color='orange')
ax.bar(indices + bar_width, idh_data['IDH-Renda'], width=bar_width, label='IDH-Renda', color='green')

# Adicionar valores em cima de cada barra
for i, bairro in enumerate(idh_data.index):
    ax.text(indices[i] - bar_width, idh_data['IDH-Educação'][i], f"{idh_data['IDH-Educação'][i]:.2f}", ha='center', va='bottom', fontsize=8)
    ax.text(indices[i], idh_data['IDH-Longevidade'][i], f"{idh_data['IDH-Longevidade'][i]:.2f}", ha='center', va='bottom', fontsize=8)
    ax.text(indices[i] + bar_width, idh_data['IDH-Renda'][i], f"{idh_data['IDH-Renda'][i]:.2f}", ha='center', va='bottom', fontsize=8)

# Configurações adicionais do gráfico
ax.set_xticks(indices)
ax.set_xticklabels(idh_data.index, rotation=90)
ax.set_xlim(min(indices) - bar_width*2, max(indices) + bar_width*2)  # Ajustar limites para remover espaços vazios
ax.set_xlabel('Bairros')
ax.set_ylabel('Valor do IDH')
ax.set_title('Valores de IDH por Componente e Bairro')
ax.legend()

plt.tight_layout()
plt.show()

# Perguntar ao usuário quais bairros deseja mostrar
input_bairros = input("Quais bairros você quer mostrar? (Separe os nomes por vírgulas): ")
bairros_selecionados = [bairro.strip() for bairro in input_bairros.split(',') if bairro.strip() in df['Bairros'].values]

# Selecionar bairros aleatórios se necessário
if len(bairros_selecionados) < 15:
    bairros_aleatorios = df[~df['Bairros'].isin(bairros_selecionados)]['Bairros'].sample(n=15-len(bairros_selecionados), random_state=1).tolist()
    bairros_finais = bairros_selecionados + bairros_aleatorios
else:
    bairros_finais = bairros_selecionados[:15]  # Garantir que só sejam escolhidos 15 bairros

# Filtrar o DataFrame para mostrar apenas os bairros selecionados
idh_data = df[df['Bairros'].isin(bairros_finais)][['Bairros', 'IDH-Educação', 'IDH-Longevidade', 'IDH-Renda']]
idh_data = idh_data.set_index('Bairros')

# Configurações do gráfico
fig, ax = plt.subplots(figsize=(30, 12))  # Tamanho do gráfico

# Parâmetros ajustados
bar_width = 0.2  # Largura das barras reduzida para acomodar o espaçamento
espacamento_bairros = 0.5  # Espaço extra entre cada conjunto de bairros
indices = np.arange(len(idh_data)) * (3 * bar_width + espacamento_bairros)  # Ajustar posições com o espaçamento entre bairros

# Plotar cada componente do IDH com espaçamento entre os bairros
ax.bar(indices - bar_width, idh_data['IDH-Educação'], width=bar_width, label='IDH-Educação', color='blue')
ax.bar(indices, idh_data['IDH-Longevidade'], width=bar_width, label='IDH-Longevidade', color='orange')
ax.bar(indices + bar_width, idh_data['IDH-Renda'], width=bar_width, label='IDH-Renda', color='green')

# Adicionar valores em cima de cada barra
for i, bairro in enumerate(idh_data.index):
    ax.text(indices[i] - bar_width, idh_data['IDH-Educação'][i], f"{idh_data['IDH-Educação'][i]:.2f}", ha='center', va='bottom', fontsize=8)
    ax.text(indices[i], idh_data['IDH-Longevidade'][i], f"{idh_data['IDH-Longevidade'][i]:.2f}", ha='center', va='bottom', fontsize=8)
    ax.text(indices[i] + bar_width, idh_data['IDH-Renda'][i], f"{idh_data['IDH-Renda'][i]:.2f}", ha='center', va='bottom', fontsize=8)

# Configurações adicionais do gráfico
ax.set_xticks(indices)
ax.set_xticklabels(idh_data.index, rotation=90)
ax.set_xlim(min(indices) - bar_width * 2, max(indices) + bar_width * 2)  # Ajuste para eliminar espaços vazios nas extremidades
ax.set_xlabel('Bairros')
ax.set_ylabel('Valor do IDH')
ax.set_title('Valores de IDH por Componente e Bairro')
ax.legend()

plt.tight_layout()
plt.show()

#Criação de um novo gráfico referente ao "Mapa de Calor do IDH de Fortaleza"

print(df.columns)

plt.figure(figsize=(10, 8))

#definindo os valores de IDH
heatmap_data = df.pivot_table(index='Bairros', values='IDH', aggfunc='mean')


sns.heatmap(heatmap_data, cmap='YlGnBu', annot=True, fmt=".2f", linewidths=0.5)
plt.xlabel('Regional')
plt.ylabel('Bairros')
plt.title('Mapa de Calor do IDH de Fortaleza')
plt.show()

#Selecionando colunas para a clusterização
X = df[['IDH-Educação', 'IDH-Longevidade', 'IDH-Renda']]

# Selecionando colunas relevantes para o K-Means
X = df[['IDH-Educação', 'IDH-Longevidade', 'IDH-Renda']]

# **Machine Learning - Algoritmo K-Means para Clusterização**

# Método do cotovelo para encontrar o número ideal de clusters
wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, init='k-means++', random_state=42)
    kmeans.fit(X)
    wcss.append(kmeans.inertia_)

# Plotando o método do cotovelo
plt.figure(figsize=(10, 5))
plt.plot(range(1, 11), wcss)
plt.title("Método do Cotovelo")
plt.xlabel("Número de Clusters")
plt.ylabel("WCSS")
plt.show()

# Treinamento do modelo com o número de clusters escolhido
n_clusters = 5
kmeans = KMeans(n_clusters=n_clusters, init='k-means++', random_state=42)
y_kmeans = kmeans.fit_predict(X)

# Avaliação do modelo usando o coeficiente de silhueta
silhouette_avg = silhouette_score(X, kmeans.labels_)
print("Coeficiente de silhueta:", silhouette_avg)

# Adicionando os clusters ao DataFrame original
df['cluster'] = y_kmeans

# Gráfico 3D dos clusters
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
colors = ['red', 'blue', 'green', 'yellow', 'orange']

for cluster in df['cluster'].unique():
    cluster_data = df[df['cluster'] == cluster]
    ax.scatter(cluster_data['IDH-Renda'], cluster_data['IDH-Educação'], cluster_data['IDH-Longevidade'],
               c=colors[cluster], label=f'Cluster {cluster}')

ax.set_xlabel('IDH-Renda')
ax.set_ylabel('IDH-Educação')
ax.set_zlabel('IDH-Longevidade')
ax.set_title('Clusters de Bairros em Fortaleza')
ax.legend()
plt.show()

cluster1 = df[df["cluster"] == 1]
cluster1.describe()

cluster2 = df[df["cluster"] == 2]
cluster2.describe()

cluster3 = df[df["cluster"] == 3]
cluster3.describe()

cluster4 = df[df["cluster"] == 4]
cluster4.describe()

#Criação de gráfico de correlação das IDHs

correlation_matrix = df[['IDH-Educação', 'IDH-Longevidade', 'IDH-Renda']].corr()

# Mapa de calor
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Matriz de Correlação')
plt.show()

from sklearn.decomposition import PCA

pca = PCA(n_components=3)
pca.fit(X)

# Variância explicada por cada componente
explained_variance = pca.explained_variance_ratio_
print('Variância explicada por cada componente:', explained_variance)

# Componentes principais
components = pd.DataFrame(pca.components_, columns=X.columns)
print('Componentes principais:')
print(components)

n_clusters = 5

# Executar o algoritmo de clustering (K-means)
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
df['cluster'] = kmeans.fit_predict(df[['IDH-Renda', 'IDH-Educação']])

# Filtrar e selecionar 5 bairros de cada cluster
selected_bairros = []
for cluster in range(n_clusters):
    cluster_bairros = df[df['cluster'] == cluster].nlargest(5, 'IDH-Renda')
    selected_bairros.append(cluster_bairros)

df_selected = pd.concat(selected_bairros)

# Plotar o gráfico com os bairros selecionados
plt.figure(figsize=(10, 8))
scatter = plt.scatter(df_selected['IDH-Renda'], df_selected['IDH-Educação'], c=df_selected['cluster'], cmap='Set1')

# Adicionar rótulos aos pontos com espaçamento
for i, row in df_selected.iterrows():
    plt.text(row['IDH-Renda'], row['IDH-Educação'], row['Bairros'], fontsize=8, ha='center', va='center')

plt.xlabel('IDH-Renda')
plt.ylabel('IDH-Educação')
plt.title('Distribuição dos Bairros em Fortaleza por Cluster')
legend_elements = scatter.legend_elements()[0]
legend_labels = ['Cluster 0', 'Cluster 1', 'Cluster 2', 'Cluster 3']
plt.legend(legend_elements, legend_labels, title='Clusters')

plt.show()

# Definir o número de clusters desejado
n_clusters = 5

# Executar o algoritmo de clustering (K-means)
kmeans = KMeans(n_clusters=n_clusters, random_state=42)
df['cluster'] = kmeans.fit_predict(df[['IDH', 'IDH-Longevidade']])

# Filtrar e selecionar 5 bairros de cada cluster
selected_bairros = []
for cluster in range(n_clusters):
    cluster_bairros = df[df['cluster'] == cluster].nlargest(5, 'IDH')
    selected_bairros.append(cluster_bairros)

df_selected = pd.concat(selected_bairros)

# Plotar o gráfico com os bairros selecionados
plt.figure(figsize=(10, 8))
scatter = plt.scatter(df_selected['IDH'], df_selected['IDH-Longevidade'], c=df_selected['cluster'], cmap='Set1')

# Adicionar rótulos aos pontos com espaçamento
for i, row in df_selected.iterrows():
    plt.text(row['IDH'], row['IDH-Longevidade'], row['Bairros'], fontsize=8, ha='center', va='center')

plt.xlabel('IDH')
plt.ylabel('IDH-Longevidade')
plt.title('Distribuição dos Bairros em Fortaleza por Cluster')
legend_elements = scatter.legend_elements()[0]
legend_labels = ['Cluster 0', 'Cluster 1', 'Cluster 2', 'Cluster 3']
plt.legend(legend_elements, legend_labels, title='Clusters')

plt.show()